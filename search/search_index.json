{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Anywise","text":"<p>Decouples the intention behind the execution of application services from the application service itself, whether subjective (via Command) or objective (via Event).</p> <p>Eliminates direct dependencies on implementation details.</p> <p>Improves development speed, reduces testing complexity, and enhances the overall reusability of the program.</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install anywise\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Let start with defining messages:</p> <pre><code>from anywise import Anywise, MessageRegistry, use\n\nclass UserCommand: ...\nclass CreateUser(UserCommand): ...\nclass UserEvent: ...\nclass UserCreated(UserEvent): ...\n</code></pre> <p>Next step, Register command handler and event listeners.</p>"},{"location":"#command-handler-event-listeners","title":"Command Handler / Event Listeners","text":""},{"location":"#function-based-handlerlistener","title":"Function-based handler/listener","text":"<pre><code>registry = MessageRegistry(command_base=UserCommand, event_base=UserEvent)\n\n@registry \nasync def create_user(\n     command: CreateUser, \n     anywise: Anywise, \n     service: UserService = use(user_service_factory)\n):\n    await users.signup(command.username, command.user_email)\n    await anywise.publish(UserCreated(command.username, command.user_email))\n\n@registry\nasync def notify_user(event: UserCreated, service: EmailSender):\n     await service.send_greeting(command.user_email)\n\n# you can also menually register many handler at once\n\nregistry.register_all(create_user, notify_user)\n</code></pre>"},{"location":"#example-usage-with-fastapi","title":"Example usage with fastapi","text":"<pre><code>from anywise import Anywise\nfrom anywise.integration.fastapi import FastWise\n\n@app.post(\"/users\")\nasync def signup(command: CreateUser, anywise: FastWise) -&gt; User:\n    return await anywise.send(command)\n</code></pre>"},{"location":"#rationale","title":"Rationale","text":"<p>Anywise is designed and built to:</p> <ol> <li>promote best practices and enterprise architecture in python.</li> <li>isolating bussiness logic from input ports, encapsulate application core, maxmize reusability of logic, allowing one app for web api, kafka, flink, etc.</li> <li>let you write less code than other wise</li> </ol>"},{"location":"architecture/","title":"Architecture","text":"<p>we will talk about how to use anywise for applying architectural patterns in event driven microservices</p>"},{"location":"architecture/#terms-and-concepts","title":"Terms and concepts","text":"<p>Before we start, let's clearify some terms and concept, so that you know what do we mean when we use these words.</p> <ul> <li> <p>A <code>Message</code> is a pure data object that is used to carry data that is needed for our application to respond. Also known as data transfer object.</p> </li> <li> <p>A <code>Message</code> class often contains no behavior(method), and is immutable.</p> </li> </ul>"},{"location":"architecture/#command-query-and-event","title":"Command, Query and Event","text":"<ul> <li> <p><code>Command</code> carries pre-define intend, each command should have a corresponding <code>handler</code> that will mutate state, in the context of DDD, each command will always trigger a behavior of an aggregate root.</p> </li> <li> <p><code>Query</code> is a subclass of Command, where it also carry pre-define intend, but instead of mutate state, it will be responded by a present state of the application.</p> </li> </ul> <p>In other words, command and query corresponds to write and read.</p> <ul> <li><code>Event</code> carries a record of an interested domain-related activity, often captures the side effect caused by a <code>Command</code>. an <code>Event</code> can have zero to many <code>listener</code>s</li> </ul>"},{"location":"architecture/#ddd","title":"DDD","text":"<p>anywise can be used to publish domain events, without specifically collect events from entity</p> <p>reference: https://github.com/cosmicpython/code/blob/master/src/allocation/service_layer/unit_of_work.py</p> <pre><code>def collect_new_events(self):\n    for product in self.products.seen:\n        while product.events:\n            yield product.events.pop(0)\n</code></pre>"},{"location":"architecture/#vertical-slicing","title":"Vertical slicing","text":"<p>we can use anywise to avoid direct dependent on other slices.</p> <p>for example, given two slice, order and payment,  we want order to process once payment is finished</p> <pre><code>from fastapi import APIRouter, Depends\nfrom app.base.auth import AuthService\nfrom app.payments.message import CreatePayment, PaymentResponse\nfrom app.payments.services import PaymentService\n\nrouter = APIRouter()\n\n@router.post(\"/\", response_model=PaymentResponseSchema)\ndef create_payment(\n    create_payment: CreatePayment, current_user: str = Depends(AuthService.get_current_user)\n):\n    res = await anywise.send(create_payment, dict(user=current_user))\n    event = PaymentCreatedEvent(payment_id=res.id)\n    await anywise.publish(event)\n    return res\n</code></pre> <p>in order service, we can listen to the event</p> <pre><code>from app.order.service import OrderService\n\n@events.listen(PaymentCreatedEvent)\nasync def start_order(event: PaymentCreatedEvent):\n    await order_service.start_order(event.payment_id)\n</code></pre>"},{"location":"architecture/#cqrs","title":"CQRS","text":""},{"location":"architecture/#event-sourcing","title":"Event Sourcing","text":""},{"location":"architecture/#choreography-orchestration","title":"Choreography, Orchestration","text":""},{"location":"features/","title":"Features","text":""},{"location":"features/#dependency-injection","title":"Dependency injection","text":"<ul> <li>builtin dependency injection(powerd by ididi)<ul> <li>Define your dependency after the message parameter, they will be resolved when you send a command or publish an event.</li> <li>For each handler that handles the initial message, a scope will be created to manage resources.</li> <li>Subsequent handlers will share the same scope.</li> </ul> </li> </ul>"},{"location":"features/#remote-handler","title":"Remote handler","text":"<p>...</p>"},{"location":"features/#event-sourcing","title":"Event Sourcing","text":"<p>...</p>"},{"location":"features/#framework-integration","title":"Framework integration","text":"<p>...</p>"},{"location":"roadmap/","title":"RoadMap","text":""},{"location":"roadmap/#current-limitations-and-planning-fix","title":"Current limitations and planning fix","text":"<ul> <li> <p>currently <code>Anywise.send</code> does not provide accurate typing information, but annotated as return <code>typing.Any</code> This have no runtime effect, but is a good to have feature. It will be solved before anywise v1.0.0</p> </li> <li> <p>currently if a handler needs to receive <code>context</code>, it must declear the context parameter with name <code>context</code>, in future it will be decleared as type.</p> </li> </ul>"},{"location":"roadmap/#faq","title":"FAQ","text":"<p>On its way here...</p>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#message-registry","title":"Message Registry","text":"<p>Use <code>MessageRegistry</code> to decorate / register a function as a handler of a command.</p> <pre><code>from anywise import MessageRegistry\n\nregistry = MessageRegistry(command_base=UserCommand)\n\nregistry.register(hanlder_func)\n</code></pre> <p>Use <code>registry.factory</code> to declear how a dependency should be resolved</p> <pre><code>@registry.factory\nasync def conn(engine=use(engine_factory)) -&gt; AsyncGenerator[AsyncConnection, None]:\n    async with engine.begin() as conn:\n        yield conn\n</code></pre> <ul> <li>factory must declear return type</li> <li>factory declear with generator/async generator would be considered as a <code>resource</code></li> <li>resource will be opened / closed automatically across message</li> <li>declear <code>reuse=False</code> to config if the factory should be reused across handler/listeners.</li> </ul> <p>checkout ididi-github for more details</p>"},{"location":"tutorial/#command","title":"Command","text":""},{"location":"tutorial/#command-handler","title":"Command handler","text":"<p>a handler <code>h</code> for command <code>c</code> can be either a method or a function</p> <ul> <li>For fucntion handler, dependency will be injected into <code>h</code> the handler during <code>anywise.send(c)</code></li> <li>For method handler, dependency will be injected into its owner type during <code>anywise.send(c)</code></li> </ul> <pre><code>registry = MessageRegistry(command_base=UserEvent)\n\n@registry\nclass UserService:\n    def __init__(self, users: UserRepository=use(user_repo_factory), anywise: Anywise):\n        self._users = users\n        self._anywise = anywise\n\n    async def create_user(self, command: CreateUser, context: Mapping[str, Any]):\n        await self._users.add(User(command.user_name, command.user_email))\n        await self._anywise.publish(UserCreated(**comand))\n</code></pre> <ul> <li>Function/Method that declear a subclass of the command base in its signature will be treated as a handler to that command and its subcommand.</li> <li>If two or more handlers that handle the same command are registered, only the lastly registered one will be used.</li> </ul>"},{"location":"tutorial/#command-guard","title":"Command Guard","text":"<p>you might use Guard to intercept command handling</p> <p>It is recommended to</p> <ul> <li>Encapsulate non-business logic inside guards, such as logging, rate-limiting, etc.</li> <li>Store non-business related context info in a mutable <code>context</code>, such as <code>request-id</code>, <code>x-country</code>, etc.</li> <li>Use inheritance-hierarchy to assign targets for guads.</li> </ul>"},{"location":"tutorial/#guard-target","title":"guard target","text":"<ul> <li>The first non-self parameter is regarded as the guard target, which should be a command.</li> <li>targeting a base command means targeting all its subcommand, and the base command itself.</li> <li>targeting <code>typing.Any</code> or <code>object</code> to make a global command guard.</li> <li>global command guard will always be executed than normal guards</li> </ul>"},{"location":"tutorial/#function-based-guard","title":"Function-based Guard","text":"<ul> <li>use <code>MessageRegistry.pre_handle</code> to register a function that only gets called before the command is handled.</li> </ul> <pre><code>@registry.pre_handle\nasync def validate_command(command: UserCommand, context: dict[str, ty.Any]) -&gt; None:\n    if not context[\"user\"]:\n        raise InvalidAuthError\n</code></pre> <ul> <li>use <code>MessageRegistry.post_handle</code> to register a function that only gets called after the command is handled</li> </ul> <pre><code>@registry.post_handle\nasync def log_result(command: UserCommand, context: dict[str, ty.Any], response: R) -&gt; R:\n    logger.info(f\"{command} is handled with {response=}\")\n    return response\n</code></pre> <ul> <li>Guard that guards for a base command will handle all subcommand of the base command</li> </ul> <pre><code>from anywise import AnyWise, MessageRegistry\n\nuser_registry = MessageRegistry(command_base=UserCommand)\n\n# in this case, `mark` will be called before `handler_update` or `handler_create` gets called.\n\n@user_registry.pre_handle\nasync def mark(command: UserCommand, context: dict[str, ty.Any]) -&gt; None:\n    if not context.get(\"processed_by\"):\n        context[\"processed_by\"] = [\"1\"]\n    else:\n        context[\"processed_by\"].append(\"1\")\n\n@user_registry\nasync def handler_create(command: CreateUser, context: dict[str, ty.Any]):\n    assert context[\"processed_by\"]\n    return \"done\"\n\n@user_registry\nasync def handler_update(command: UpdateUser, context: dict[str, ty.Any]):\n    return \"done\"\n</code></pre> <p>Guard that guards for a base command will handle all subcommand of the base command</p>"},{"location":"tutorial/#advanced-class-based-guard","title":"Advanced class-based Guard","text":"<p>Example:</p>"},{"location":"tutorial/#class-based-guard","title":"class-based Guard","text":"<p>Inherit from <code>BaseGuard</code> to make a class-based command guard</p> <pre><code>from anywise import BaseGuard\n\nclass LogginGuard(BaseGuard):\n    _next_guard: GuardFunc\n\n    def __init__(self, logger: ty.Any):\n        super().__init__()\n        self._logger = logger\n\n    async def __call__(self, command: Any, context: dict[str, object]):\n        if (request_id := context.get(\"request_id\")) is None:\n            context[\"request_id\"] = request_id = str(uuid4())\n\n        with logger.contextualize(request_id=request_id):\n            try:\n                response = await self._next_guard(command, context)\n            except Exception as exc:\n                logger.error(exc)\n                response =  ErrorResponse(command, context, self._next_guard)\n            else:\n                logger.success(\n                    f\"Logging request: {request_id}, got response `{response}`\"\n                )\n            finally:\n                return response\n\n# you can add either an instance of LoggingGuard:\nuser_registry.add_guard(LogginGuard(logger=logger), targets=[UserCommand])\n\n# or the LoggingGuard class, which will be dynamically injected during anywise.send\nuser_registry.add_guard(LogginGuard, targets=[UserCommand])\n</code></pre>"},{"location":"tutorial/#event","title":"Event","text":""},{"location":"tutorial/#event-listeners","title":"Event Listeners","text":"<ul> <li>same register rule, but each event can have multiple listeners</li> <li>event listener can declear <code>context</code> in its signature, if so, a immutable <code>context</code> object will be shared between listeners.</li> <li>event handler is supposed to return <code>None</code>, if it returns a value, it will be ignored.</li> </ul> <pre><code>registry = MessageRegistry(event_base=UserEvent)\n@registry\nasync def notify_user(event: UserCreated, context: Mapping[str, Any], email: EmailSender) -&gt; None:\n    await email.greet_user(event.user_name, event.user_email)\n\n@registry\nasync def validate_payment(event: UserCreated, context: Mapping[str, Any], payment: PaymentService) -&gt; None:\n    await payment.validte_user_payment(event.user_name, event.user_email)\n</code></pre>"},{"location":"tutorial/#provide-startegy-to-alter-send-and-publish-behavior","title":"Provide Startegy to alter send and publish behavior","text":"<ul> <li>Provide an async callble <code>SendStrategy</code> or <code>PublishStrategy</code> to change the default behavior of how anywise send or publish message</li> <li>You might provide strategy like a class with dependencies and async def call for more advanced usage.</li> </ul> <pre><code>from anywise import Anywise, MessageRegistry, concurrent_publish, EventListeners\n\nanywise = Anywise(user_message_registry, publisher=concurrent_publish)\n\n# now all event listeners that listen to type(event) will be called concurrently\nawait anywise.publish(event) \n</code></pre>"},{"location":"tutorial/#inspect","title":"Inspect","text":"<p>anywise provide a simple api for inspection, make debugging easy.</p> <p>Use <code>Anywise.inspect</code> to inspect registered handler / listeners</p> <pre><code>print(anywise.inspect[UserCreated])\n\n&gt;&gt;&gt; [&lt;function react_to_event at 0x7fe032786020&gt;]\n</code></pre>"},{"location":"architectures/ddd/","title":"Domain Driven Design","text":"<p>In this chapter we will talk about how to use anywise in a codebase that follows domain driven design, or a DDD-oriented microservice.</p>"},{"location":"architectures/ddd/#architecture","title":"Architecture","text":"<pre><code>graph TD\n    MS[MessageSource]\n\n    subgraph Application Layer\n    M[Message]\n    A[Anywise]\n    AS[Application Service]\n    end\n\n    subgraph Domain Layer\n    DS[Domain Service]\n    DM[Domain Model]\n    end\n\n    subgraph Infrastructures\n    R[Repository]\n    C[Cache]\n    end\n\n    MS --&gt; M\n    MS --&gt; A\n    A --&gt; AS\n    A --&gt; M\n    AS --&gt; DS\n    DS --&gt; DM\n\n    AS --&gt; R\n    R --&gt; DS\n    R --&gt; DM\n\n    AS --&gt; C\n    C --&gt; DM\n</code></pre>"},{"location":"architectures/microservice/","title":"Microservice","text":""},{"location":"architectures/microservice/#introduction","title":"Introduction","text":"<p>In this chapter, we will talk about how to apply anywise in a microservice architecture as well as event driven architecture</p> <p>EDA is a superset of microservices, it focus on the communication between services.</p>"},{"location":"architectures/microservice/#microservices-architecture","title":"<code>Microservices Architecture</code>","text":"<p>Microservices architecture is a design pattern where a system is broken down into small, independent services that communicate over a network. Each service focuses on a specific business function, is loosely coupled, and is independently deployable. These services can be developed, deployed, and scaled independently, enabling agility, flexibility, and fault tolerance.</p>"},{"location":"architectures/microservice/#event-driven-architecture-eda","title":"<code>Event-Driven Architecture</code> (EDA)","text":"<p>Event-driven architecture is a design pattern where systems react to events (changes in state or significant occurrences). In EDA, components (or services) produce, listen to, and react to events, typically through event brokers or message queues. It allows for asynchronous communication between components, enabling highly decoupled and scalable systems. It is widely used in systems where real-time processing or loosely coupled interaction is needed.</p>"},{"location":"architectures/microservice/#orchestration","title":"Orchestration","text":"<pre><code>sequenceDiagram\n    participant MS as Message Source\n    participant D as Decoder\n    box Anywise\n        participant CG as Command Guards\n        participant CH as Command Handler\n        participant EH as Event Handlers\n    end\n    participant E as Encoder\n    participant ES as Event Sink\n\n    %% Command Flow\n    alt command\n        MS-&gt;&gt;D: Raw Message\n        Note right of D: decode as command\n        D-&gt;&gt;CG: Command Message\n        Note right of CG: non-bussiness logic\n        CG-&gt;&gt;CH: Command Message\n        Note right of CH: handle command\n        Note right of CH: mutate state\n        CH-&gt;&gt;EH: Publish Events\n        EH-&gt;&gt;E: Event Message\n        Note right of E: encode envents\n        E-&gt;&gt;ES: sink Events\n        Note right of ES: persistent events\n    else query\n        %% Query Flow\n        MS-&gt;&gt;D: Raw Message\n        Note right of D: decode as query\n        D-&gt;&gt;CG: Query Message\n        Note right of CG: defined behaviors\n        CG-&gt;&gt;CH: Query  Message\n        Note right of CH: execute Query\n        CH--&gt;&gt;CG: Query Result\n        Note left of CG: validate result\n        CG--&gt;&gt;D: Validated Result \n        D--&gt;&gt;MS: Response\n    end\n</code></pre>"},{"location":"architectures/microservice/#choreography","title":"Choreography","text":"<pre><code>sequenceDiagram\n    participant MS as Message Source\n    participant D as Decoder\n    box Anywise\n        participant EH as Event Handlers\n        participant CG as Command Guards\n        participant CH as Command Handler\n    end\n    participant ES as Event Sink\n\n    MS-&gt;&gt;D: Raw Message\n    Note right of D: Decode as Event\n    D-&gt;&gt;EH: Event Message\n    Note right of EH: react to event\n    EH-&gt;&gt;CG: Command Message\n    Note right of CG: non-business logic\n    CG-&gt;&gt;CH: Command Message\n    Note right of CH: Handle command\n    Note right of CH: mutate state\n    Note right of CH: emits event\n    CH-&gt;&gt;ES: Event-carried state transfer\n</code></pre> <p>In this case, Message source is often a message queue, e.g. kafka</p>"},{"location":"architectures/sink/","title":"Coming soon","text":""},{"location":"architectures/source/","title":"Source","text":""},{"location":"architectures/source/#features","title":"Features","text":""},{"location":"architectures/source/#use-mark-to-mark-a-handler-with-command","title":"use mark to mark a handler with command","text":""},{"location":"architectures/source/#mark-a-module","title":"mark a module","text":"<pre><code># app/features/app.py\n\nfrom app.features import user\n\n# this would recursively search for all classes and functions\nmark(UserCommand)(user)\n</code></pre>"},{"location":"architectures/source/#autoroute","title":"autoroute","text":"<pre><code>class CreateUser:\n    web_config = WebConfig(\n        \"users\"\n    )\n\nor \n\nautoroute(\"users\", CreateUser)\n\n# ======= Client =======\n\napp = FastAPI(\n    title=\"app\",\n    description=\"my app\",\n    lifespan=lifespan,\n)\napp.include_router(autorouter())\n</code></pre>"},{"location":"architectures/source/#sink","title":"sink","text":"<p>transfer your events to correspnding sinks</p> <p>AWS SQS Sink # forward message to AWS SQS Kafka Sink # to kafka HTTP Sink # to a http api Database Sink # store to database</p> <pre><code>sink = AWSEventSink(\n    queue_url=\"test-queue\",\n    region_name=\"eu-central-1\"\n)\n\nclass UserCreatedEvent:\n    ...\n\n\nsink.add_event(UserCreatedEvent)\naw = AnyWise(\n    event_sinks = [AWSEventSink]\n)\n\nawait aw.publish(UserCreatedEvent)\n# this goes directly to corresponding sink\n</code></pre>"},{"location":"architectures/source/#port","title":"Port","text":"<p>Ports are source of data to our domain</p> <p>Kafka port FastAPI port Rabbit port</p> <pre><code>import uvloop\nfrom aiokafka import Kafka\nfrom anywise.source import KafkaSource\n\nbroker = Kafka(connect_info)\nsource = KafkaSource(broker)\n\n\nasync def main():\n    aw = AnyWise(\n        source = KafkaSource\n    )\n\n    await aw.listen()\n</code></pre>"},{"location":"architectures/source/#generate-doc","title":"Generate doc","text":"<p>integrate exceptions integrate openapi integrate https://www.asyncapi.com/en</p>"},{"location":"architectures/source/#source-service-sink-architecture","title":"Source-Service-Sink Architecture","text":"<pre><code> Command      Event\n</code></pre> <p>Source  -&gt;  Service  -&gt;  Sink</p> <p>we receive command from source service handles commands and generate side-effect we record these side-effect with events. then redirect these events to sink.</p> <p>reference:</p> <p>https://medium.com/ssense-tech/hexagonal-architecture-there-are-always-two-sides-to-every-story-bc0780ed7d9c</p>"},{"location":"architectures/sss_architecture/","title":"Source-Service-Sink Architecture","text":"<p>Message Source sends commnad to command handler, command handler handles the command, mutate state and persist it to database, then record the side-effect by emitting a event, which will be handled by event handles, event handles will either handle the event directly, or forward it to other services the event will eventually be stored in the event sink.</p> <pre><code>sequenceDiagram\n    participant MS as Message Source\n    box Service\n        participant CH as Command Handler\n        participant EH as Event Handlers\n    end\n    participant ES as Event Sink\n\n    %% Command Flow\n    alt command\n        MS-&gt;&gt;CH: Command Message\n        Note right of CH: handle command\n        Note right of CH: mutate state\n        CH-&gt;&gt;EH: Publish Events\n        EH-&gt;&gt;ES: Event Message\n    else query\n        %% Query Flow\n        MS-&gt;&gt;CH: Query Message\n        CH--&gt;&gt;MS: Query Result \n    end\n</code></pre>"}]}